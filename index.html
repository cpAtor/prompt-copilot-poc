<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prompt Copilot</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> <!-- Added marked.js CDN -->
  <style>
    /* Custom scrollbar for chat areas */
    .chat-area::-webkit-scrollbar {
      width: 8px;
    }

    .chat-area::-webkit-scrollbar-track {
      background: #1e293b; /* slate-800 */
      border-radius: 4px;
    }

    .chat-area::-webkit-scrollbar-thumb {
      background: #475569; /* slate-600 */
      border-radius: 4px;
    }

    .chat-area::-webkit-scrollbar-thumb:hover {
      background: #64748b; /* slate-500 */
    }

    /* Modal overlay */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 50;
        padding: 1rem; /* Add padding for small screens */
    }

    /* Modal content */
    .modal-content {
        background-color: #1e293b; /* slate-800 */
        padding: 1.5rem;
        border-radius: 0.75rem; /* rounded-xl */
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5); /* shadow-2xl */
        width: 100%;
        max-width: 42rem; /* max-w-2xl */
        display: flex;
        flex-direction: column;
        max-height: 90vh; /* max-h-[90vh] */
    }

    /* Ensure full height for layout */
    html, body, #root {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden; /* Prevent body scrollbars when panels are full height */
    }
    .main-container {
        display: flex;
        flex-direction: column;
        height: 100vh; /* Full viewport height */
    }
    .content-wrapper {
        display: flex;
        flex-grow: 1; /* Allows this to fill remaining vertical space */
        overflow: hidden; /* Prevent internal scrollbars from affecting layout */
        min-height: 0; /* ADDED to ensure it can shrink properly in flex context */
    }
    .panel {
        height: 100%; /* Make panels take full height of their container */
        overflow: hidden; /* CHANGED from overflow-y: auto - This is crucial to constrain panel size */
        display: flex; /* Added to make inner content flex correctly */
        flex-direction: column; /* Added for inner content stacking */
    }
    .resizer {
        width: 10px;
        cursor: col-resize;
        background-color: #4A5568; /* slate-600 */
        z-index: 10; /* Ensure it's above other content */
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .resizer:hover {
        background-color: #718096; /* slate-500 */
    }
    .resizer-handle { /* Optional: for a visual cue on the resizer */
        width: 4px;
        height: 40px;
        background-color: #A0AEC0; /* slate-400 */
        border-radius: 2px;
    }

    /* Basic styling for Markdown preview elements if Tailwind Typography plugin is not active */
    /* These styles target elements generated by Markdown within a .prose container */
    .prose h1 {
      font-size: 1.875rem; /* like text-2xl */
      font-weight: 600;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      line-height: 1.2;
    }
    .prose h2 {
      font-size: 1.5rem; /* like text-xl */
      font-weight: 600;
      margin-top: 1.25rem;
      margin-bottom: 0.5rem;
      line-height: 1.2;
    }
    .prose h3 {
      font-size: 1.25rem; /* like text-lg */
      font-weight: 600;
      margin-top: 1rem;
      margin-bottom: 0.25rem;
      line-height: 1.2;
    }
    .prose h4 {
      font-size: 1.125rem; /* like text-base (but bold) */
      font-weight: 600;
      margin-top: 1rem;
      margin-bottom: 0.25rem;
      line-height: 1.2;
    }
    .prose p {
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      /* line-height is inherited from parent div's leading-relaxed (1.625) */
    }
    .prose ul, .prose ol {
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      padding-left: 1.75rem; /* Adjusted for better visual nesting */
    }
    .prose li {
      margin-top: 0.35rem;
      margin-bottom: 0.35rem;
    }
    .prose li > p { /* For paragraphs inside list items */
        margin-top: 0.35rem;
        margin-bottom: 0.35rem;
    }
    .prose ul {
        list-style-type: disc;
    }
    .prose ol {
        list-style-type: decimal;
    }
    .prose blockquote {
      margin-top: 1rem;
      margin-bottom: 1rem;
      padding-left: 1rem;
      border-left-width: 0.25rem; /* 4px */
      border-left-style: solid;
      border-left-color: #4b5563; /* slate-600, good for prose-invert */
      font-style: italic;
      color: #9ca3af; /* slate-400 */
    }
    .prose blockquote p {
        margin: 0; /* Reset paragraph margins inside blockquote if needed */
    }
    .prose a {
      color: #93c5fd; /* blue-300, good for prose-invert */
      text-decoration: underline;
    }
    .prose a:hover {
      color: #60a5fa; /* blue-400 */
    }
    .prose code {
      background-color: #374151; /* slate-700 */
      color: #e5e7eb; /* slate-200 */
      padding: 0.125em 0.35em; /* Adjusted padding */
      border-radius: 0.25rem;
      font-size: 0.875em; /* slightly smaller than surrounding text */
      /* Ensure inline code does not break words awkwardly if possible */
      word-break: break-word; /* Or break-all if preferred */
    }
    .prose pre {
      background-color: #1f2937; /* slate-800 */
      color: #d1d5db; /* slate-300 */
      padding: 0.875rem; /* 14px */
      border-radius: 0.375rem; /* rounded-md */
      overflow-x: auto;
      margin-top: 1rem;
      margin-bottom: 1rem;
      font-size: 0.875em; /* Match code font size */
    }
    .prose pre code {
      background-color: transparent;
      padding: 0;
      font-size: inherit; /* inherit from pre */
      color: inherit;
      word-break: normal; /* Allow normal breaks in code blocks */
    }
    .prose hr {
        border-top-width: 1px;
        border-color: #374151; /* slate-700 */
        margin-top: 2rem;
        margin-bottom: 2rem;
    }
    .prose strong {
        font-weight: 600; /* semibold */
    }
    .prose em {
        font-style: italic;
    }
    .prose img {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border-radius: 0.375rem; /* Optional: if you want rounded images */
    }
    .prose table {
        width: auto; /* Or 100% if you prefer full-width tables */
        margin-top: 1rem;
        margin-bottom: 1rem;
        border-collapse: collapse;
        font-size: 0.875em;
    }
    .prose th, .prose td {
        border: 1px solid #4b5563; /* slate-600 */
        padding: 0.5rem 0.75rem;
    }
    .prose th {
        font-weight: 600;
        background-color: #374151; /* slate-700 */
    }
  </style>
</head>
<body class="bg-slate-900 text-white">
  <div id="root"></div>
  <script type="text/babel">
    // Access createRoot directly from ReactDOM for UMD builds
    const createRoot = ReactDOM.createRoot;

    // Helper: Generic Gemini API call function
    const callGeminiApi = async (apiKey, messages, systemInstructionText = null, tools = null) => {
      const API_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${apiKey}`;

      // Request body for generateContent with function calling
      const requestBody = {
        contents: messages, // messages should be in Gemini Content format: [{role, parts}, ...]
      };

      if (systemInstructionText) {
        requestBody.systemInstruction = { parts: [{ text: systemInstructionText }] };
      }

      // If tools (array of function declarations) are provided, wrap them correctly
      if (tools && tools.length > 0) {
        requestBody.tools = [{ functionDeclarations: tools }];
      }

      console.log('Sending to Gemini API (generateContent with tools):', JSON.stringify(requestBody, null, 2));

      try {
        const response = await fetch(API_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          const errorData = await response.json();
          console.error('Gemini API Error Response:', errorData);
          throw new Error(`API Error: ${response.status} ${response.statusText}. ${errorData?.error?.message || 'Unknown error'}`);
        }

        const data = await response.json();
        console.log('Gemini API Success Response:', data);

        const candidate = data.candidates && data.candidates.length > 0 ? data.candidates[0] : null;

        if (candidate) {
          // Ensure content and content.parts exist, even if empty, for consistent handling
          const content = candidate.content || { parts: [], role: 'model' }; // Default to model role if content was stripped (e.g. safety)
          if (!content.parts) {
            content.parts = [];
          }
          if (!content.role) { // Assign a role if missing, typically 'model' for candidate content
            content.role = 'model';
          }
          return { content: content, finishReason: candidate.finishReason, safetyRatings: candidate.safetyRatings };
        } else {
          // Truly unexpected structure or no candidate (e.g. if API returned 200 but malformed/empty candidates array)
          console.error('Unexpected API response structure or no candidate:', data);
          return { error: 'Could not parse AI response. No valid candidate found.' };
        }

      } catch (error) {
        console.error('Error calling Gemini API:', error);
        return { error: error.message || 'Failed to fetch from Gemini API.' };
      }
    };


    // Main Application Component
    function App() {
      const { useState, useEffect, useCallback, useRef } = React;

      // State variables
      const [apiKey, setApiKey] = useState('');
      const [currentPrompt, setCurrentPrompt] = useState('// Your amazing prompt starts here...\n// Example: You are a helpful assistant. Summarize the following text in three concise sentences.\n\nText to summarize: [Provide text here]');
      const [promptHistory, setPromptHistory] = useState([currentPrompt]);
      const [historyIndex, setHistoryIndex] = useState(0);
      const [copilotSuggestions, setCopilotSuggestions] = useState('');

      // State for the Pair Programming Chat (Left Panel)
      const [pairProgrammingChatMessages, setPairProgrammingChatMessages] = useState([]);
      const [pairProgrammingChatInput, setPairProgrammingChatInput] = useState('');
      const [isLoadingPairProgrammingChat, setIsLoadingPairProgrammingChat] = useState(false);
      const pairProgrammingChatInputRef = useRef(null); // ADDED: Ref for the chat input textarea

      // State for the Test Chat Modal
      const [isTestChatOpen, setIsTestChatOpen] = useState(false);
      const [testChatMessages, setTestChatMessages] = useState([]);
      const [isLoadingTestChat, setIsLoadingTestChat] = useState(false);
      const [testChatInput, setTestChatInput] = useState('');

      // State for Suggestions
      const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);

      // Error state for the main application
      const [appError, setAppError] = useState(''); // Renamed to avoid potential conflict
      const [appNotification, setAppNotification] = useState(null); // For success/info/warning messages

      const pairProgrammingChatAreaRef = useRef(null); // Ref for scrolling pair programming chat
      const testChatAreaRef = useRef(null); // Ref for scrolling test chat

      // State for active tab in the left panel
      const [activeLeftTab, setActiveLeftTab] = useState('chat'); // 'chat' or 'suggestions'
      const [activeRightTab, setActiveRightTab] = useState('editor'); // New state for right panel tabs: 'editor' or 'preview'

      // State for left panel width
      const [leftPanelWidth, setLeftPanelWidth] = useState(50); // Initial width in percentage

      // Ref for the resizer element
      const resizerRef = useRef(null);
      const leftPanelRef = useRef(null);
      const rightPanelRef = useRef(null);

      // Calculate word count for the current prompt
      const wordCount = currentPrompt.trim() === '' ? 0 : currentPrompt.trim().split(/\s+/).filter(Boolean).length;

      // Load API key and prompt history from local storage on initial render
      useEffect(() => {
        const storedApiKey = localStorage.getItem('geminiApiKey');
        if (storedApiKey) {
          setApiKey(storedApiKey);
        }
        const storedPromptHistory = localStorage.getItem('promptHistory');
        if (storedPromptHistory) {
            try {
                const history = JSON.parse(storedPromptHistory);
                if (history && Array.isArray(history) && history.length > 0) {
                    setPromptHistory(history);
                    setHistoryIndex(history.length - 1);
                    setCurrentPrompt(history[history.length - 1]);
                }
            } catch (e) {
                console.error("Failed to parse prompt history from local storage", e);
                setPromptHistory([currentPrompt]);
                setHistoryIndex(0);
            }
        }
         // Initialize pair programming chat with a welcome message
         setPairProgrammingChatMessages([{ id: Date.now(), text: "Hello! I'm your AI Prompt Pair Programmer. How can I help you refine your prompt today?", sender: 'ai' }]);
      }, []);

      // Effect to save prompt history to local storage whenever it changes
      useEffect(() => {
        localStorage.setItem('promptHistory', JSON.stringify(promptHistory));
      }, [promptHistory]);

      // Effect to scroll pair programming chat to bottom when new messages arrive
      useEffect(() => {
        if (pairProgrammingChatAreaRef.current) {
          pairProgrammingChatAreaRef.current.scrollTop = pairProgrammingChatAreaRef.current.scrollHeight;
        }
      }, [pairProgrammingChatMessages]);

       // Effect to scroll test chat to bottom when new messages arrive
      useEffect(() => {
        if (testChatAreaRef.current) {
          testChatAreaRef.current.scrollTop = testChatAreaRef.current.scrollHeight;
        }
      }, [testChatMessages]);

      // ADDED: Effect to auto-resize pair programming chat input textarea
      useEffect(() => {
        const textarea = pairProgrammingChatInputRef.current;
        if (textarea) {
          // Temporarily reset height to allow scrollHeight to be calculated correctly
          textarea.style.height = 'auto';

          const computedStyle = getComputedStyle(textarea);
          const lineHeight = parseFloat(computedStyle.lineHeight);
          // Ensure padding and border values are numbers, default to 0 if not parseable
          const paddingTop = parseFloat(computedStyle.paddingTop) || 0;
          const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;
          const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;
          const borderBottom = parseFloat(computedStyle.borderBottomWidth) || 0;

          const scrollHeight = textarea.scrollHeight;
          
          const maxLines = 6;
          // Calculate the max height for 6 lines of text content + padding + border
          const maxHeightForSixLines = (lineHeight * maxLines) + paddingTop + paddingBottom + borderTop + borderBottom;

          if (scrollHeight > maxHeightForSixLines) {
            textarea.style.height = `${maxHeightForSixLines}px`;
            textarea.style.overflowY = 'auto'; // Show scrollbar if content exceeds 6 lines
          } else {
            textarea.style.height = `${scrollHeight}px`;
            textarea.style.overflowY = 'hidden'; // Hide scrollbar if content fits within 6 lines
          }
        }
      }, [pairProgrammingChatInput]); // Rerun when input value changes

      // Effect to handle resizing
      useEffect(() => {
        const resizer = resizerRef.current;
        const leftPanel = leftPanelRef.current;
        const rightPanel = rightPanelRef.current;

        if (!resizer || !leftPanel || !rightPanel) return;

        let isResizing = false;

        const onMouseDown = (e) => {
            isResizing = true;
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            // Prevent text selection during drag
            document.body.style.userSelect = 'none'; 
        };

        const onMouseMove = (e) => {
            if (!isResizing) return;

            // Calculate new width for the left panel
            // The clientX gives the horizontal coordinate within the application's viewport
            // The getBoundingClientRect().left gives the distance from the left edge of the viewport to the left edge of the container
            const containerOffsetLeft = leftPanel.parentElement.getBoundingClientRect().left;
            let newLeftWidth = ((e.clientX - containerOffsetLeft) / leftPanel.parentElement.offsetWidth) * 100;

            // Clamp the width between, say, 20% and 80%
            newLeftWidth = Math.max(20, Math.min(newLeftWidth, 80));
            
            setLeftPanelWidth(newLeftWidth);
        };

        const onMouseUp = () => {
            isResizing = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.body.style.userSelect = ''; // Re-enable text selection
        };

        resizer.addEventListener('mousedown', onMouseDown);

        return () => {
            resizer.removeEventListener('mousedown', onMouseDown);
            document.removeEventListener('mousemove', onMouseMove); // Cleanup in case mouseup didn't fire
            document.removeEventListener('mouseup', onMouseUp); // Cleanup
            if (document.body) document.body.style.userSelect = ''; // Ensure cleanup
        };
      }, []);

      // Function to save API key to local storage (modified for auto-save via input change)
      const handleApiKeyInputChange = (e) => {
        const newKey = e.target.value;
        setApiKey(newKey);
        setAppError(''); // Clear any previous errors

        if (newKey.trim() !== '') {
            localStorage.setItem('geminiApiKey', newKey);
            setAppNotification({ message: 'API Key saved automatically!', type: 'success' });
            setTimeout(() => {
                setAppNotification(null);
            }, 3000);
        } else {
            // If the user manually clears the input field
            localStorage.removeItem('geminiApiKey');
            // Optionally, notify that the key was cleared by this action
            // setAppNotification({ message: 'API Key cleared from input.', type: 'info' });
            // setTimeout(() => setAppNotification(null), 3000);
        }
      };

      // Function to clear API key from local storage
      const handleClearApiKey = () => {
        localStorage.removeItem('geminiApiKey');
        setApiKey('');
        setAppNotification({ message: 'API Key cleared from local storage!', type: 'info' });
        setTimeout(() => {
            setAppNotification(null);
        }, 3000);
      };

      // Function to save the current prompt to history
      const handleSavePrompt = () => {
          if (currentPrompt !== promptHistory[historyIndex]) {
              const newHistory = promptHistory.slice(0, historyIndex + 1);
              setPromptHistory([...newHistory, currentPrompt]);
              setHistoryIndex(newHistory.length);
              setAppNotification({ message: 'Prompt saved to history!', type: 'success' });
              setTimeout(() => {
                  setAppNotification(null);
              }, 3000);
          } else {
               setAppNotification({ message: 'No changes to save!', type: 'warning' });
               setTimeout(() => {
                   setAppNotification(null);
               }, 3000);
          }
      };

      // Function to undo prompt changes
      const handleUndo = () => {
          if (historyIndex > 0) {
              setHistoryIndex(historyIndex - 1);
              setCurrentPrompt(promptHistory[historyIndex - 1]);
          }
      };

      // Function to redo prompt changes
      const handleRedo = () => {
          if (historyIndex < promptHistory.length - 1) {
              setHistoryIndex(historyIndex + 1);
              setCurrentPrompt(promptHistory[historyIndex + 1]);
          }
      };

      // Static System Prompt for the Pair Programming Chat AI
      const PAIR_PROGRAMMING_SYSTEM_ROLE_PROMPT = `You are an AI Prompt Pair Programmer.

Available tools:
- update_editor_content(new_editor_content: string): Updates the main editor with new content.

Your primary goal is to help the user iterate on and refine a main prompt they are working on. This main prompt is intended to be used by the user to instruct another Large Language Model (LLM).

The user will provide their current main prompt (from the editor) and a message or request related to it.

When you want to modify the main editor, call the update_editor_content function. The new_editor_content you provide should be a complete, self-contained prompt that the user can copy and paste to instruct a different LLM. This means the new_editor_content should clearly define:
1.  The **role** the target LLM should adopt (e.g., "You are an AI Travel Assistant").
2.  The **goal** or task for the target LLM (e.g., "Your primary goal is to assist users in planning...").
3.  Any specific **instructions** for the target LLM on how to behave, what information to collect, or what output format to use.

Important Guidelines:
1. You must use the update_editor_content tool for **any and all** edits to the main editor. Do NOT output prompt revisions directly as text in the chat.
2. The content you generate for new_editor_content should be written as if a human is instructing an AI. For example, instead of saying "I require the following details...", the prompt should say something like "You must ask the user for the following details...".
3. You can and should call update_editor_content on **every** turn where you propose changes, including iterative refinements or follow-up adjustments.
4. After calling the tool, wait for the application to confirm execution before providing any follow-up messages.

For conversational replies (questions, feedback, or discussion without changing the prompt), respond with plain text messages.

Always adhere to these instructions on every turn. If you suggest a change to the prompt, call update_editor_content.`;

      // Tool definition for updating the editor content
      const editorUpdateTool = {
        name: "update_editor_content",
        description: "Updates the main editor with new content. Use this when you have a specific version of the prompt to suggest directly.",
        parameters: {
          type: "OBJECT",
          properties: {
            new_editor_content: {
              type: "STRING",
              description: "The complete new content for the main editor."
            }
          },
          required: ["new_editor_content"]
        }
      };

      // Handle sending a message in the Pair Programming Chat
      const handleSendPairProgrammingMessage = async () => {
          if (pairProgrammingChatInput.trim() === '' || !apiKey) {
              if(!apiKey) setAppError('API Key is missing for chat.');
              return;
          }

          const newUserMessage = { id: Date.now(), text: pairProgrammingChatInput, sender: 'user' };
          setPairProgrammingChatMessages(prev => [...prev, newUserMessage]); // Add user message immediately
          const currentInputFromChatBox = pairProgrammingChatInput;
          setPairProgrammingChatInput('');
          setIsLoadingPairProgrammingChat(true);
          setAppError('');

          const userMessageForAI = `Here's the main prompt I'm working on (from the editor):\n---\n${currentPrompt}\n---\n
My current message/request is:\n---
${currentInputFromChatBox}\n---`;

          // Prepare chat history for the API call
          // Note: The actual geminiChatHistory sent to API should not include the welcome message or system-info/error messages.
          // It should be a sequence of user and model (AI) turns.
          // For simplicity in this example, we are just sending the latest user message with the canvas prompt.
          // A more robust solution would filter pairProgrammingChatMessages to build a proper history.
          let geminiChatHistoryForAPI = [
            { role: 'user', parts: [{ text: userMessageForAI }] }
          ];

          const response1 = await callGeminiApi(
              apiKey,
              geminiChatHistoryForAPI,
              PAIR_PROGRAMMING_SYSTEM_ROLE_PROMPT,
              [editorUpdateTool] // Updated tool
          );

          if (response1.error) {
              setIsLoadingPairProgrammingChat(false);
              const errMsg = `Chat Error: ${response1.error}`;
              setAppError(errMsg);
              setPairProgrammingChatMessages(prev => [...prev, {id: Date.now() + 1, text: errMsg, sender: 'system-error'}]);
          } else if (response1.content && response1.content.parts) {
              const parts = response1.content.parts;
              let functionCallFromResponse1 = null;

              for (const part of parts) {
                  if (part.functionCall) {
                      functionCallFromResponse1 = part.functionCall;
                      break;
                  }
              }

              if (functionCallFromResponse1) {
                  // Function call found in the first response, prioritize it.
                  if (functionCallFromResponse1.name === 'update_editor_content') { // Updated tool name check
                      const args = functionCallFromResponse1.args;
                      const newEditorContent = args.new_editor_content; // Updated arg name

                      if (typeof newEditorContent === 'string') {
                          setCurrentPrompt(newEditorContent);
                          setPairProgrammingChatMessages(prev => [...prev, { id: Date.now() + 1, text: `AI initiated an update to the editor.`, sender: 'system-info' }]);
                          
                          const newHistory = promptHistory.slice(0, historyIndex + 1);
                          if (promptHistory[historyIndex] !== newEditorContent) {
                              setPromptHistory([...newHistory, newEditorContent]);
                              setHistoryIndex(newHistory.length);
                          }

                          // Add AI's functionCall to history for the next API call
                          geminiChatHistoryForAPI.push({ role: 'model', parts: [{ functionCall: functionCallFromResponse1 }] });

                          const functionResponsePayload = {
                              role: 'function', 
                              parts: [{
                                  functionResponse: {
                                      name: 'update_editor_content', // Updated tool name
                                      response: { name: 'update_editor_content', content: { success: true, message: 'Editor content updated successfully.' } }, // Updated tool name and message
                                  }
                              }]
                          };
                          geminiChatHistoryForAPI.push(functionResponsePayload);

                          // Second API call to get conversational response from AI
                          // setIsLoadingPairProgrammingChat is already true
                          const response2 = await callGeminiApi(
                              apiKey,
                              geminiChatHistoryForAPI,
                              PAIR_PROGRAMMING_SYSTEM_ROLE_PROMPT,
                              [editorUpdateTool] // Updated tool
                          );
                          setIsLoadingPairProgrammingChat(false);

                          if (response2.error) {
                              const errMsg = `Chat Error (after function call): ${response2.error}`;
                              setAppError(errMsg);
                              setPairProgrammingChatMessages(prev => [...prev, {id: Date.now() + 2, text: errMsg, sender: 'system-error'}]);
                          } else if (response2.content && response2.content.parts) {
                              const response2Text = response2.content.parts.map(p => p.text || '').join('\n').trim();
                              if (response2Text) {
                                 setPairProgrammingChatMessages(prev => [...prev, { id: Date.now() + 2, text: response2Text, sender: 'ai' }]);
                              } else {
                                 console.log("Second API call after function execution returned no text.");
                                 // Optionally, add a generic confirmation if AI doesn't provide one.
                                 // setPairProgrammingChatMessages(prev => [...prev, { id: Date.now() + 2, text: "Prompt updated.", sender: 'ai' }]);
                              }
                          } else {
                                setIsLoadingPairProgrammingChat(false);
                                const errMsg = 'Chat Error: Unexpected response structure after function call.';
                                setAppError(errMsg);
                                setPairProgrammingChatMessages(prev => [...prev, {id: Date.now() + 2, text: errMsg, sender: 'system-error'}]);
                          }
                      } else {
                          setIsLoadingPairProgrammingChat(false);
                          const errMsg = 'Chat Error: AI function call (update_editor_content) had invalid arguments.'; // Updated error message
                          setAppError(errMsg);
                          setPairProgrammingChatMessages(prev => [...prev, {id: Date.now() +1, text: errMsg, sender: 'system-error'}]);
                      }
                  } else {
                       setIsLoadingPairProgrammingChat(false);
                       const errMsg = `Chat Error: AI called an unknown function: ${functionCallFromResponse1.name}`;
                       setAppError(errMsg);
                       setPairProgrammingChatMessages(prev => [...prev, {id: Date.now() + 1, text: errMsg, sender: 'system-error'}]);
                  }
              } else {
                  // No function call found in the first response, process all parts as text.
                  setIsLoadingPairProgrammingChat(false);
                  const textResponse = parts.map(p => p.text || '').join('\n').trim();
                  if (textResponse) {
                      setPairProgrammingChatMessages(prev => [...prev, { id: Date.now() + 1, text: textResponse, sender: 'ai' }]);
                  } else {
                      console.log("First API call returned no function call and no text.");
                      setPairProgrammingChatMessages(prev => [...prev, { id: Date.now() + 1, text: "[AI sent an empty or non-text response]", sender: 'system-info' }]);
                  }
              }
          } else {
              setIsLoadingPairProgrammingChat(false);
              const errMsg = 'Chat Error: Received an unexpected response structure from the API.';
              setAppError(errMsg);
              setPairProgrammingChatMessages(prev => [...prev, {id: Date.now() + 1, text: errMsg, sender: 'system-error'}]);
          }
      };

      // Handle getting copilot suggestions (still uses API)
      const handleGetCopilotSuggestions = async () => {
        if (!apiKey) {
          setAppError('Please enter and save your API Key first.');
          return;
        }
        setIsLoadingSuggestions(true);
        setAppError(''); // Clear main app error
        setCopilotSuggestions('');

        const suggestionFullPrompt = `You are an AI assistant that provides suggestions to improve a given prompt.
        Analyze the following user prompt and provide 3-5 actionable suggestions to make it more effective, clear, or comprehensive.
        Focus on aspects like specificity, context, desired output format, and tone.
        User Prompt (from Editor):
        ---
        ${currentPrompt}
        ---
        Provide your suggestions in a numbered list.`;

        // Call the generic Gemini API function
        // The suggestionFullPrompt is the entire user request.
        const response = await callGeminiApi(
            apiKey, 
            [{ role: 'user', parts: [{ text: suggestionFullPrompt }] }] // messages as Gemini Content array
            // No systemInstructionText needed as the prompt is self-contained
            // No tools needed for suggestions
        );

        if (response.error) {
          setAppError(`Copilot Suggestions Error: ${response.error}`);
        } else if (response.content && response.content.parts && response.content.parts.length > 0) {
          const suggestionsText = response.content.parts.map(p => p.text || '').join('\n').trim();
          if (suggestionsText) {
            setCopilotSuggestions(suggestionsText);
          } else {
            setAppError('Copilot Suggestions Error: API response contained no usable text content.');
          }
        } else {
          setAppError('Copilot Suggestions Error: Received an empty or malformed response from the API.');
        }
        setIsLoadingSuggestions(false);
      };

      // Handle opening the test chat modal
      const openTestChat = () => {
          if (!apiKey) {
              setAppError('Please enter and save your API Key to test the prompt.');
              return;
          }
          setAppError(''); // Clear main app error
          // Clear previous test chat messages when opening
          setTestChatMessages([]);
          setIsTestChatOpen(true);
      };

      // Handle sending a message in the test chat modal
      const handleSendTestMessage = async () => {
        if (testChatInput.trim() === '' || !apiKey) {
          if(!apiKey) setAppError('API Key is missing for chat.');
          return;
        }

        // Save the current prompt to history before testing, if it's changed
        if (currentPrompt !== promptHistory[historyIndex]) {
             const newHistory = promptHistory.slice(0, historyIndex + 1);
             setPromptHistory([...newHistory, currentPrompt]);
             setHistoryIndex(newHistory.length);
        }

        const newUserMessage = { id: Date.now(), text: testChatInput, sender: 'user' };
        // Add user message to UI immediately
        setTestChatMessages(prevMessages => [...prevMessages, newUserMessage]);
        const currentTestInput = testChatInput; // Capture before clearing
        setTestChatInput('');
        setIsLoadingTestChat(true);
        setAppError(''); // Clear main app error

        // Map UI messages to Gemini Content format for the API call
        // Build history from the most recent testChatMessages state before adding the new user message
        const currentChatHistoryForAPI = testChatMessages.map(msg => ({
            role: msg.sender === 'user' ? 'user' : 'model',
            parts: [{ text: msg.text }]
        }));
        // Add the new user message (using currentTestInput)
        currentChatHistoryForAPI.push({ role: 'user', parts: [{ text: currentTestInput }] });

        // Call the generic Gemini API function
        // currentPrompt (from canvas) acts as the system instruction for the test chat
        const response = await callGeminiApi(
            apiKey, 
            currentChatHistoryForAPI, // Use the constructed history including the latest user message
            currentPrompt   // systemInstructionText (the prompt being tested)
            // No tools needed for test chat
        );

        setIsLoadingTestChat(false); // Set loading to false after API call completes

        if (response.error) {
          const errorMessage = `Test Chat Error: ${response.error}`; // response.error is already a string
          setAppError(errorMessage); // Display error in main app error area
          setTestChatMessages(prev => [...prev, {id: Date.now() + 1, text: errorMessage, sender: 'system-error'}]);
        } else if (response.content && response.content.parts && response.content.parts.length > 0) {
          // Concatenate text from all parts, though typically there's one for a simple text response.
          const aiResponseText = response.content.parts.map(part => part.text || '').join('\n').trim();
          
          if (aiResponseText) {
            setTestChatMessages(prev => [...prev, { id: Date.now() + 1, text: aiResponseText, sender: 'ai' }]);
          } else {
            // This case handles if parts exist but all text fields are empty or missing.
            const emptyPartsMsg = 'Test Chat Error: AI responded with empty content.';
            setAppError(emptyPartsMsg);
            setTestChatMessages(prev => [...prev, {id: Date.now() + 1, text: emptyPartsMsg, sender: 'system-error'}]);
          }
        } else {
          // This case handles if response.content is missing, or parts array is missing/empty.
          // This could also catch safety blocks if content is stripped and parts becomes empty.
          const unexpectedResponseMsg = 'Test Chat Error: AI response was empty, malformed, or blocked.';
          setAppError(unexpectedResponseMsg);
          setTestChatMessages(prev => [...prev, {id: Date.now() + 1, text: unexpectedResponseMsg, sender: 'system-error'}]);
        }
      };

      // Main component UI
      return (
        <div className="main-container bg-slate-900 text-slate-100 font-sans p-1">
          {/* Header and API Key Section - Combined and Stuck to Top */}
          <header className="sticky top-0 z-40 bg-slate-900/80 backdrop-blur-md shadow-lg">
            <div className="w-full p-3"> {/* MODIFIED: Added padding to this container */}
              <div className="relative flex justify-center items-center mb-2"> {/* MODIFIED: For title centering and button positioning */}
                <h1 className="text-3xl md:text-4xl font-bold text-white text-center">
                  Prompt Copilot
                </h1>
                {apiKey && ( // Conditionally render Clear Key button here
                  <button
                    onClick={handleClearApiKey}
                    className="absolute right-0 top-1/2 -translate-y-1/2 bg-red-600 hover:bg-red-700 text-white font-semibold py-1.5 px-3 text-xs rounded transition-colors shadow-sm hover:shadow-md"
                    title="Clear API Key"
                  >
                    Clear Key
                  </button>
                )}
              </div>
              {/* API Key Section - Conditionally rendered */}
              {!apiKey && (
                <section className="bg-slate-800/60 rounded-md p-2">
                  <div className="flex flex-col sm:flex-row gap-1 items-center min-h-[34px]"> 
                    <input
                        type="password"
                        value={apiKey} // This will be empty string here, but kept for consistency if logic changes
                        onChange={handleApiKeyInputChange}
                        placeholder="Gemini API Key"
                        className="flex-grow p-1.5 text-xs bg-slate-700 border border-slate-600 rounded focus:ring-1 focus:ring-purple-500 focus:border-purple-500 outline-none transition-all w-full"
                    />
                  </div>
                </section>
              )}
            </div>
          </header>

          {/* Main Content Area - Takes remaining space */}
          <div className="w-full flex-grow flex flex-col min-h-0 overflow-hidden"> {/* MODIFIED: Added min-h-0 and overflow-hidden */}
            {/* Error Display */}
            {appError && (
              <div className="bg-red-500/20 border border-red-700 text-red-300 px-4 py-3 rounded-lg relative mb-4" role="alert">
                <strong className="font-bold">Error: </strong>
                <span className="block sm:inline">{appError}</span>
                <button onClick={() => setAppError('')} className="absolute top-0 bottom-0 right-0 px-4 py-3 text-red-300 hover:text-red-100">&times;</button>
              </div>
            )}

            {/* Notification Display */}
            {appNotification && (
              <div className={`px-4 py-3 rounded-lg relative mb-4 border text-sm
                ${appNotification.type === 'success' ? 'bg-green-500/20 border-green-700 text-green-300' : ''}
                ${appNotification.type === 'info'    ? 'bg-blue-500/20 border-blue-700 text-blue-300'   : ''}
                ${appNotification.type === 'warning' ? 'bg-yellow-500/20 border-yellow-700 text-yellow-300' : ''}
              `} role="alert">
                <span className="block sm:inline">{appNotification.message}</span>
                <button onClick={() => setAppNotification(null)} className={`absolute top-0 bottom-0 right-0 px-4 py-3
                  ${appNotification.type === 'success' ? 'text-green-300 hover:text-green-100' : ''}
                  ${appNotification.type === 'info'    ? 'text-blue-300 hover:text-blue-100'   : ''}
                  ${appNotification.type === 'warning' ? 'text-yellow-300 hover:text-yellow-100' : ''}
                `}>&times;</button>
              </div>
            )}

            {/* Main Layout: Movable Partition */}
            <div className="content-wrapper flex-grow">
              {/* Left Panel: Tabs for Chat and Suggestions */}
              <section 
                ref={leftPanelRef}
                className="panel bg-slate-800 rounded-xl shadow-2xl p-2" 
                style={{ width: `${leftPanelWidth}%` }}
              >
                {/* Tab Buttons */}
                <div className="flex mb-4 border-b border-slate-700">
                  <button
                    onClick={() => setActiveLeftTab('chat')}
                    className={`py-2 px-4 -mb-px font-semibold text-sm rounded-t-md transition-colors
                                ${activeLeftTab === 'chat' ? 'border border-slate-700 border-b-transparent bg-slate-800 text-pink-400' : 'text-slate-400 hover:text-pink-300'}`}
                  >
                    Pair Programming Chat
                  </button>
                  <button
                    onClick={() => setActiveLeftTab('suggestions')}
                    className={`py-2 px-4 -mb-px font-semibold text-sm rounded-t-md transition-colors
                                ${activeLeftTab === 'suggestions' ? 'border border-slate-700 border-b-transparent bg-slate-800 text-sky-400' : 'text-slate-400 hover:text-sky-300'}`}
                  >
                    Copilot Suggestions
                  </button>
                </div>

                {/* Conditional Content based on active tab */}
                {activeLeftTab === 'chat' && (
                  <div className="flex flex-col flex-grow min-h-0"> {/* Chat Tab Content - Added min-h-0 */}
                    <h2 className="text-xl font-semibold mb-3 text-green-300 sr-only">Pair Programming Chat</h2>
                    {!apiKey && (
                        <div className="flex-grow flex flex-col justify-center items-center text-slate-500 p-4">
                            <p className="mb-3 text-center">Please enter and save your API key to enable the chat.</p>
                            <div className="mt-2 text-xs text-slate-400 bg-slate-700 p-3 rounded-md w-full max-w-md">
                                <p className="font-semibold text-sm text-slate-300 mb-1">How to get a Gemini API Key:</p>
                                <ol className="list-decimal list-inside pl-2 space-y-1">
                                    <li>Go to <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:text-purple-300 underline">Google AI Studio</a>.</li>
                                    <li>Click on "Get API key" or "Create API key".</li>
                                    <li>Follow the instructions to create a new project and generate your API key.</li>
                                    <li>Copy the generated API key and paste it into the input field in the header above.</li>
                                </ol>
                            </div>
                        </div>
                    )}
                    {apiKey && (
                        <>
                            <p className="text-xs text-slate-400 mb-4 border-b border-slate-700 pb-2 italic">
                                <span className="font-semibold text-slate-300">Context:</span> Discuss and refine the prompt in the canvas with the AI.
                            </p>
                            <div ref={pairProgrammingChatAreaRef} className="flex-grow overflow-y-auto mb-4 space-y-3 pr-2 chat-area"> {/* REMOVED min-h-[300px] lg:min-h-0 */}
                                {pairProgrammingChatMessages.map((msg) => (
                                    <div
                                        key={msg.id}
                                        className={`p-3 rounded-lg max-w-[85%] break-words ${
                                            msg.sender === 'user' ? 'bg-purple-600 ml-auto' :
                                            msg.sender === 'ai' ? 'bg-sky-600 mr-auto' :
                                            msg.sender === 'system-info' ? 'bg-slate-600 text-center text-xs italic w-full text-slate-300' :
                                            'bg-red-600 text-center text-xs italic w-full text-red-100' // system-error
                                        }`}
                                    >
                                        <p className="text-sm whitespace-pre-wrap">{msg.text}</p>
                                    </div>
                                ))}
                                {isLoadingPairProgrammingChat && (
                                    <div className="p-3 rounded-lg max-w-[85%] bg-sky-600 mr-auto animate-pulse">
                                        <p className="text-sm">Gemini is thinking...</p>
                                    </div>
                                )}
                            </div>

                            <div className="relative mt-auto"> {/* MODIFIED: Was flex gap-3 */}
                                <textarea
                                    ref={pairProgrammingChatInputRef} // ADDED ref
                                    value={pairProgrammingChatInput}
                                    onChange={(e) => setPairProgrammingChatInput(e.target.value)}
                                    onKeyPress={(e) => {
                                        if (e.key === 'Enter' && !e.shiftKey && !isLoadingPairProgrammingChat) {
                                            e.preventDefault(); // Prevent newline in textarea
                                            handleSendPairProgrammingMessage();
                                        }
                                    }}
                                    placeholder="Chat with the AI (Shift+Enter for new line)"
                                    className="w-full p-3 pr-12 bg-slate-700 border border-slate-600 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-green-500 outline-none resize-none text-sm leading-relaxed" // REMOVED: overflow-y-auto, max-h-XX
                                    // rows="1" REMOVED
                                    disabled={isLoadingPairProgrammingChat}
                                    style={{ overflowY: 'hidden' }} // Initial overflow state, JS will manage it
                                />
                                <button
                                    onClick={handleSendPairProgrammingMessage}
                                    disabled={isLoadingPairProgrammingChat || !pairProgrammingChatInput.trim()}
                                    className="absolute right-2 top-1/2 -translate-y-1/2 p-2 rounded-full text-green-400 hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors" // MODIFIED classes for icon button
                                    title="Send message" // ADDED title
                                >
                                    {/* SVG Send Icon */}
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5">
                                        <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" />
                                    </svg>
                                </button>
                            </div>
                        </>
                    )}
                  </div>
                )}

                {activeLeftTab === 'suggestions' && (
                  <div className="flex flex-col flex-grow min-h-0"> {/* Suggestions Tab Content - MODIFIED h-full to min-h-0 */}
                    <h2 className="text-xl font-semibold mb-3 text-sky-300 sr-only">Copilot Suggestions</h2>
                     {!apiKey && (
                        <div className="flex-grow flex justify-center items-center text-slate-500">
                            Please enter and save your API key to get suggestions.
                        </div>
                    )}
                    {apiKey && (
                        <>
                            <button
                                onClick={handleGetCopilotSuggestions}
                                disabled={isLoadingSuggestions || !apiKey}
                                className="w-full bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-4 rounded-lg mb-4 transition-colors shadow-md hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                            >
                                {isLoadingSuggestions && copilotSuggestions === '' ? 'Analyzing...' : 'Get Suggestions for Current Prompt'}
                            </button>
                            {isLoadingSuggestions && copilotSuggestions === '' && (
                                <div className="flex-grow flex justify-center items-center h-full">
                                    <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-sky-400"></div>
                                </div>
                            )}
                            {copilotSuggestions && (
                                <div className="flex-grow p-3 bg-slate-700 border border-slate-600 rounded-lg overflow-y-auto text-sm leading-relaxed min-h-[200px]">
                                    <pre className="whitespace-pre-wrap">{copilotSuggestions}</pre>
                                </div>
                            )}
                            {!isLoadingSuggestions && !copilotSuggestions && (
                                <div className="flex-grow flex justify-center items-center p-3 bg-slate-700/50 border border-slate-600 rounded-lg text-slate-500 min-h-[200px]">
                                    Click "Get Suggestions" to analyze the prompt in the editor.
                                </div>
                            )}
                        </>
                    )}
                  </div>
                )}
              </section>

              {/* Resizer */}
              <div ref={resizerRef} className="resizer">
                <div className="resizer-handle"></div>
              </div>

              {/* Right Panel: Editor & Preview */}
              <section 
                ref={rightPanelRef}
                className="panel bg-slate-800 rounded-xl shadow-2xl p-2"
                style={{ width: `${100 - leftPanelWidth}%` }}
              >
                {/* Editor/Preview Section - now takes full height of this right panel */}
                <div className="flex flex-col bg-slate-800 rounded-xl shadow-2xl flex-grow min-h-0"> {/* MODIFIED: Added min-h-0 */}
                    {/* Tab Buttons for Right Panel */}
                    <div className="flex mb-3 border-b border-slate-700">
                        <button
                            onClick={() => setActiveRightTab('editor')}
                            className={`py-2 px-4 -mb-px font-semibold text-sm rounded-t-md transition-colors
                                        ${activeRightTab === 'editor' ? 'border border-slate-700 border-b-transparent bg-slate-800 text-pink-400' : 'text-slate-400 hover:text-pink-300'}`}
                        >
                            Editor
                        </button>
                        <button
                            onClick={() => setActiveRightTab('preview')}
                            className={`py-2 px-4 -mb-px font-semibold text-sm rounded-t-md transition-colors
                                        ${activeRightTab === 'preview' ? 'border border-slate-700 border-b-transparent bg-slate-800 text-cyan-400' : 'text-slate-400 hover:text-cyan-300'}`}
                        >
                            Preview
                        </button>
                    </div>

                    {/* Conditional Content based on activeRightTab */}
                    {activeRightTab === 'editor' && (
                        <div className="flex flex-col flex-grow min-h-0"> {/* Editor Tab Content - MODIFIED: Added min-h-0 */}
                            <div className="flex justify-between items-center mb-3">
                                <h2 className="text-xl font-semibold text-pink-300 sr-only">Editor</h2> {/* Screen reader only title */}
                                <div className="flex items-center gap-2">
                                    <span className="text-xs text-slate-400 mr-2">{wordCount} words</span>
                                    <button
                                        onClick={handleSavePrompt}
                                        className="bg-green-500 hover:bg-green-600 text-white font-semibold py-1.5 px-3 text-xs rounded-md transition-colors shadow-sm hover:shadow-md"
                                        title="Save current prompt (Ctrl+S)"
                                    >
                                        Save
                                    </button>
                                    <button
                                        onClick={handleUndo}
                                        disabled={historyIndex === 0}
                                        className="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-1.5 px-3 text-xs rounded-md transition-colors shadow-sm hover:shadow-md disabled:opacity-50"
                                        title="Undo (Ctrl+Z)"
                                    >
                                        Undo
                                    </button>
                                    <button
                                        onClick={handleRedo}
                                        disabled={historyIndex === promptHistory.length - 1}
                                        className="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-1.5 px-3 text-xs rounded-md transition-colors shadow-sm hover:shadow-md disabled:opacity-50"
                                        title="Redo (Ctrl+Y)"
                                    >
                                        Redo
                                    </button>
                                </div>
                            </div>
                            <textarea
                                value={currentPrompt}
                                onChange={(e) => setCurrentPrompt(e.target.value)}
                                placeholder="Craft your prompt here..."
                                className="flex-grow p-4 bg-slate-700 border border-slate-600 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-pink-500 outline-none resize-none text-sm leading-relaxed" /* REMOVED min-h-[200px] lg:min-h-0 */
                            />
                             <button
                                onClick={openTestChat} // MODIFIED: Call openTestChat function
                                className="mt-4 bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors shadow-md hover:shadow-lg text-sm"
                            >
                                Test Prompt...
                            </button>
                        </div>
                    )}

                    {activeRightTab === 'preview' && (
                        <div className="flex flex-col flex-grow min-h-0"> {/* Preview Tab Content - MODIFIED h-full to min-h-0 */}
                            <h2 className="text-xl font-semibold mb-3 text-cyan-400 sr-only">Markdown Preview</h2> {/* Screen reader only title */}
                            <div 
                                className="flex-grow p-4 bg-slate-700 border border-slate-600 rounded-lg overflow-y-auto text-sm leading-relaxed prose prose-sm prose-invert max-w-none" // Added prose classes for styling
                                dangerouslySetInnerHTML={{ __html: marked.parse(currentPrompt || '', { breaks: true, gfm: true }) }} 
                            >
                            </div>
                             <p className="text-xs text-slate-400 mt-2 text-center">Preview of the editor content rendered as Markdown.</p>
                        </div>
                    )}
                </div>
              </section>
            </div>
          </div>

          {/* Test Chat Modal */}
          {isTestChatOpen && (
            <div className="modal-overlay fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4">
              <div className="modal-content bg-slate-800 rounded-xl shadow-2xl w-full max-w-2xl flex flex-col max-h-[90vh]">
                <div className="flex justify-between items-center p-4 border-b border-slate-700">
                  <h2 className="text-xl font-semibold text-indigo-300">Test Prompt</h2>
                  <button
                    onClick={() => setIsTestChatOpen(false)}
                    className="text-slate-400 hover:text-slate-200 transition-colors"
                    title="Close Test Chat"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-7 h-7">
                      <path fillRule="evenodd" d="M5.47 5.47a.75.75 0 011.06 0L12 10.94l5.47-5.47a.75.75 0 111.06 1.06L13.06 12l5.47 5.47a.75.75 0 11-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 01-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 010-1.06z" clipRule="evenodd" />
                    </svg>
                  </button>
                </div>

                <div ref={testChatAreaRef} className="flex-grow overflow-y-auto p-4 space-y-3 chat-area">
                  {testChatMessages.map((msg) => (
                    <div
                      key={msg.id}
                      className={`p-3 rounded-lg max-w-[85%] break-words ${
                        msg.sender === 'user' ? 'bg-purple-600 ml-auto' :
                        msg.sender === 'ai' ? 'bg-indigo-600 mr-auto' :
                        'bg-red-600 text-center text-xs italic w-full text-red-100' // system-error
                      }`}
                    >
                      <p className="text-sm whitespace-pre-wrap">{msg.text}</p>
                    </div>
                  ))}
                  {isLoadingTestChat && (
                    <div className="p-3 rounded-lg max-w-[85%] bg-indigo-600 mr-auto animate-pulse">
                      <p className="text-sm">Model is responding...</p>
                    </div>
                  )}
                </div>

                <div className="p-4 border-t border-slate-700">
                  <div className="relative flex gap-2 items-end">
                    <textarea
                      value={testChatInput}
                      onChange={(e) => setTestChatInput(e.target.value)}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter' && !e.shiftKey && !isLoadingTestChat) {
                          e.preventDefault();
                          handleSendTestMessage();
                        }
                      }}
                      placeholder="Your message to test the prompt... (Shift+Enter for new line)"
                      className="flex-grow p-3 bg-slate-700 border border-slate-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none resize-none text-sm leading-relaxed"
                      rows="1"
                      style={{ maxHeight: '120px', overflowY: 'auto' }} // Auto-grows up to a certain height
                      disabled={isLoadingTestChat}
                    />
                    <button
                      onClick={handleSendTestMessage}
                      disabled={isLoadingTestChat || !testChatInput.trim()}
                      className="p-3 rounded-lg bg-indigo-500 hover:bg-indigo-600 text-white disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                      title="Send Message"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5">
                        <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" />
                      </svg>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // Ensure the React app renders after the DOM is fully loaded
    window.onload = function() {
        const container = document.getElementById('root');
        if (container) {
            const root = createRoot(container);
            root.render(<App />);
        } else {
            console.error("Root element with ID 'root' not found!");
        }
    };
  </script>
</body>
</html>
